"""
Visualization tool for probabilistic plant structures generated by the hierarchical model.
Creates graphics showing all probable plant structures with opacity based on existence probabilities.
"""

import torch
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.patches import Circle
import matplotlib.patches as mpatches
from normal_hier_surrogate_nn import HierarchicalPlantSurrogateNet
from utils_nn import build_random_parameter_file

# Configuration: Path to trained model
MODEL_PATH = "normal_hier_plant_surrogate_model.pt"

def visualize_probabilistic_plant_structure(model, params, day=25, figsize=(12, 10), 
                                          min_opacity=0.1, max_opacity=0.9, 
                                          bp_color='red', ep_color='blue',
                                          point_size=50, save_path=None):
    """
    Visualize probabilistic plant structures with opacity based on existence probabilities.
    
    Args:
        model: Trained HierarchicalPlantSurrogateNet
        params: L-system parameters (13-dimensional vector)
        day: Which growth day to visualize (0-25)
        figsize: Figure size tuple
        min_opacity: Minimum opacity for visualization
        max_opacity: Maximum opacity for high-probability points
        bp_color: Color for branch points
        ep_color: Color for end points
        point_size: Size of points in scatter plot
        save_path: Optional path to save the figure
    """
    
    model.eval()
    with torch.no_grad():
        # Prepare input
        params_tensor = torch.tensor(params, dtype=torch.float32).unsqueeze(0)
        params_norm = (params_tensor - model.input_mean) / (model.input_std + 1e-8)
        
        # Generate base plant structure
        bp_coords, bp_probs, ep_coords, ep_probs = model.structure_gen(params_norm)
        
        # Apply growth scaling for specific day
        growth_rate = np.log(10) / 25
        temporal_scale = 0.1 * np.exp(growth_rate * day)
        
        # Scale coordinates for the specified day
        bp_coords_day = bp_coords * temporal_scale
        ep_coords_day = ep_coords * temporal_scale
        
        # Convert to numpy for visualization
        bp_x = bp_coords_day[0, :, 0].cpu().numpy()
        bp_y = bp_coords_day[0, :, 1].cpu().numpy()
        bp_prob = bp_probs[0, :].cpu().numpy()
        
        ep_x = ep_coords_day[0, :, 0].cpu().numpy()
        ep_y = ep_coords_day[0, :, 1].cpu().numpy()
        ep_prob = ep_probs[0, :].cpu().numpy()
        
    # Create the visualization
    fig, ax = plt.subplots(figsize=figsize)
    
    # Scale probabilities to opacity range
    bp_opacity = min_opacity + (max_opacity - min_opacity) * bp_prob
    ep_opacity = min_opacity + (max_opacity - min_opacity) * ep_prob
    
    # Plot branch points with probability-based opacity
    for i in range(len(bp_x)):
        if bp_prob[i] > 0.01:  # Only show points with reasonable probability
            ax.scatter(bp_x[i], bp_y[i], c=bp_color, s=point_size, 
                      alpha=bp_opacity[i], marker='o', edgecolors='black', linewidths=0.5)
    
    # Plot end points with probability-based opacity
    for i in range(len(ep_x)):
        if ep_prob[i] > 0.01:  # Only show points with reasonable probability
            ax.scatter(ep_x[i], ep_y[i], c=ep_color, s=point_size, 
                      alpha=ep_opacity[i], marker='^', edgecolors='black', linewidths=0.5)
    
    # Add probability-based connections (optional - connect high probability points)
    # This creates a more plant-like structure visualization
    high_bp_indices = np.where(bp_prob > 0.3)[0]
    high_ep_indices = np.where(ep_prob > 0.3)[0]
    
    # Connect branch points to nearby end points if both have high probability
    for bp_idx in high_bp_indices:
        for ep_idx in high_ep_indices:
            distance = np.sqrt((bp_x[bp_idx] - ep_x[ep_idx])**2 + (bp_y[bp_idx] - ep_y[ep_idx])**2)
            if distance < 100:  # Reasonable connection distance
                connection_alpha = min(bp_prob[bp_idx], ep_prob[ep_idx]) * 0.5
                ax.plot([bp_x[bp_idx], ep_x[ep_idx]], [bp_y[bp_idx], ep_y[ep_idx]], 
                       'gray', alpha=connection_alpha, linewidth=1)
    
    # Customize the plot
    ax.set_xlim(0, 500 * temporal_scale)
    ax.set_ylim(0, 500 * temporal_scale)
    ax.set_xlabel('X Coordinate (pixels)', fontsize=12)
    ax.set_ylabel('Y Coordinate (pixels)', fontsize=12)
    ax.set_title(f'Probabilistic Plant Structure - Day {day}\n'
                f'Growth Scale: {temporal_scale:.2f}x, Opacity ∝ Existence Probability', 
                fontsize=14, fontweight='bold')
    
    # Add legend
    bp_legend = mpatches.Patch(color=bp_color, label='Branch Points')
    ep_legend = mpatches.Patch(color=ep_color, label='End Points')
    ax.legend(handles=[bp_legend, ep_legend], loc='upper right')
    
    # Add probability scale reference
    prob_text = (f"Opacity Scale:\n"
                f"Min: {min_opacity:.1f} (low probability)\n"
                f"Max: {max_opacity:.1f} (high probability)")
    ax.text(0.02, 0.98, prob_text, transform=ax.transAxes, 
           verticalalignment='top', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))
    
    # Add statistics
    stats_text = (f"Branch Points: {np.sum(bp_prob > 0.1):.0f} visible\n"
                 f"End Points: {np.sum(ep_prob > 0.1):.0f} visible\n"
                 f"Avg BP Prob: {np.mean(bp_prob):.3f}\n"
                 f"Avg EP Prob: {np.mean(ep_prob):.3f}")
    ax.text(0.98, 0.02, stats_text, transform=ax.transAxes, 
           verticalalignment='bottom', horizontalalignment='right',
           bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.8))
    
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
        print(f"Visualization saved to {save_path}")
    
    plt.show()
    
    return fig, ax

def create_comprehensive_plant_visualization(model, params, days=[0, 5, 10, 15, 20, 25], 
                                          figsize=(20, 14), save_path=None, 
                                          heatmap_day=25, grid_resolution=100):
    """
    Create a comprehensive visualization with heatmap background and 6 growth stages.
    Uses consistent scaling to show actual plant growth progression.
    """
    
    model.eval()
    with torch.no_grad():
        # Prepare input
        params_tensor = torch.tensor(params, dtype=torch.float32).unsqueeze(0)
        params_norm = (params_tensor - model.input_mean) / (model.input_std + 1e-8)
        
        # Generate base plant structure
        bp_coords, bp_probs, ep_coords, ep_probs = model.structure_gen(params_norm)
    
    # Calculate consistent scale (use max day for consistent viewing area)
    growth_rate = np.log(10) / 25
    max_temporal_scale = 0.1 * np.exp(growth_rate * max(days))
    max_coord = 500 * max_temporal_scale
    
    # Create main figure with subplots
    fig = plt.figure(figsize=figsize)
    
    # Create a 3x3 grid, with heatmap taking center position
    gs = fig.add_gridspec(3, 3, height_ratios=[1, 1, 1], width_ratios=[1, 1, 1])
    
    # Create heatmap background (center position)
    heatmap_ax = fig.add_subplot(gs[1, 1])
    
    # Generate heatmap for background
    heatmap_temporal_scale = 0.1 * np.exp(growth_rate * heatmap_day)
    bp_coords_heatmap = bp_coords * heatmap_temporal_scale
    ep_coords_heatmap = ep_coords * heatmap_temporal_scale
    
    # Convert to numpy for heatmap
    bp_x_heat = bp_coords_heatmap[0, :, 0].cpu().numpy()
    bp_y_heat = bp_coords_heatmap[0, :, 1].cpu().numpy()
    bp_prob_heat = bp_probs[0, :].cpu().numpy()
    
    ep_x_heat = ep_coords_heatmap[0, :, 0].cpu().numpy()
    ep_y_heat = ep_coords_heatmap[0, :, 1].cpu().numpy()
    ep_prob_heat = ep_probs[0, :].cpu().numpy()
    
    # Create probability density grid for heatmap
    x_grid = np.linspace(0, max_coord, grid_resolution)
    y_grid = np.linspace(0, max_coord, grid_resolution)
    X, Y = np.meshgrid(x_grid, y_grid)
    
    # Calculate probability density using Gaussian kernels
    prob_density = np.zeros_like(X)
    sigma = max_coord / 50  # Kernel width
    
    # Add branch point contributions to heatmap
    for i in range(len(bp_x_heat)):
        if bp_prob_heat[i] > 0.01:
            dist_sq = (X - bp_x_heat[i])**2 + (Y - bp_y_heat[i])**2
            prob_density += bp_prob_heat[i] * np.exp(-dist_sq / (2 * sigma**2))
    
    # Add end point contributions to heatmap
    for i in range(len(ep_x_heat)):
        if ep_prob_heat[i] > 0.01:
            dist_sq = (X - ep_x_heat[i])**2 + (Y - ep_y_heat[i])**2
            prob_density += ep_prob_heat[i] * np.exp(-dist_sq / (2 * sigma**2))
    
    # Draw heatmap
    im = heatmap_ax.imshow(prob_density, extent=[0, max_coord, 0, max_coord], 
                          origin='lower', cmap='hot', alpha=0.3, vmin=0, vmax=prob_density.max())
    
    # Overlay high-probability points on heatmap
    for i in range(len(bp_x_heat)):
        if bp_prob_heat[i] > 0.2:
            heatmap_ax.scatter(bp_x_heat[i], bp_y_heat[i], c='white', s=30, marker='o', 
                              edgecolors='black', linewidths=1, alpha=0.8)
    
    for i in range(len(ep_x_heat)):
        if ep_prob_heat[i] > 0.2:
            heatmap_ax.scatter(ep_x_heat[i], ep_y_heat[i], c='cyan', s=30, marker='^', 
                              edgecolors='black', linewidths=1, alpha=0.8)
    
    heatmap_ax.set_xlim(0, max_coord)
    heatmap_ax.set_ylim(0, max_coord)
    heatmap_ax.set_title(f'Probability Density\n(Day {heatmap_day})', fontweight='bold', fontsize=12)
    heatmap_ax.grid(True, alpha=0.3)
    
    # Define subplot positions (surrounding the center heatmap)
    subplot_positions = [
        (0, 0), (0, 1), (0, 2),  # Top row
        (1, 0),         (1, 2),  # Middle row (skip center)
        (2, 0), (2, 1), (2, 2)   # Bottom row
    ]
    
    # Skip position (1,1) as it's used for heatmap
    subplot_positions = [(0, 0), (0, 1), (0, 2), (1, 0), (1, 2), (2, 0)]
    
    # Create growth sequence subplots
    for idx, day in enumerate(days):
        if idx >= len(subplot_positions):
            break
            
        pos = subplot_positions[idx]
        ax = fig.add_subplot(gs[pos[0], pos[1]])
        
        # Calculate growth scale for this day
        temporal_scale = 0.1 * np.exp(growth_rate * day)
        
        # Scale coordinates
        bp_coords_day = bp_coords * temporal_scale
        ep_coords_day = ep_coords * temporal_scale
        
        # Convert to numpy
        bp_x = bp_coords_day[0, :, 0].cpu().numpy()
        bp_y = bp_coords_day[0, :, 1].cpu().numpy()
        bp_prob = bp_probs[0, :].cpu().numpy()
        
        ep_x = ep_coords_day[0, :, 0].cpu().numpy()
        ep_y = ep_coords_day[0, :, 1].cpu().numpy()
        ep_prob = ep_probs[0, :].cpu().numpy()
        
        # Plot with probability-based opacity
        bp_opacity = 0.2 + 0.8 * bp_prob
        ep_opacity = 0.2 + 0.8 * ep_prob
        
        # Plot points
        for i in range(len(bp_x)):
            if bp_prob[i] > 0.05:
                ax.scatter(bp_x[i], bp_y[i], c='red', s=25, 
                          alpha=bp_opacity[i], marker='o', edgecolors='black', linewidths=0.3)
        
        for i in range(len(ep_x)):
            if ep_prob[i] > 0.05:
                ax.scatter(ep_x[i], ep_y[i], c='blue', s=25, 
                          alpha=ep_opacity[i], marker='^', edgecolors='black', linewidths=0.3)
        
        # Use consistent scale for all subplots to show growth
        ax.set_xlim(0, max_coord)
        ax.set_ylim(0, max_coord)
        ax.set_title(f'Day {day}\n({temporal_scale:.2f}x scale)', fontweight='bold', fontsize=10)
        ax.grid(True, alpha=0.3)
        
        # Add axis labels only to edge subplots
        if pos[0] == 2:  # Bottom row
            ax.set_xlabel('X Coordinate', fontsize=9)
        if pos[1] == 0:  # Left column
            ax.set_ylabel('Y Coordinate', fontsize=9)
    
    # Add overall title and legend
    fig.suptitle('Probabilistic Plant Growth Analysis\nOpacity ∝ Existence Probability | Consistent Scale Shows Growth', 
                fontsize=16, fontweight='bold', y=0.95)
    
    # Add legend
    legend_elements = [
        mpatches.Patch(color='red', alpha=0.7, label='Branch Points'),
        mpatches.Patch(color='blue', alpha=0.7, label='End Points'),
        mpatches.Patch(color='orange', alpha=0.5, label='Probability Density')
    ]
    
    # Place legend in the bottom right corner of the figure
    fig.legend(handles=legend_elements, loc='lower right', bbox_to_anchor=(0.98, 0.02))
    
    # Add colorbar for heatmap
    cbar = plt.colorbar(im, ax=heatmap_ax, fraction=0.046, pad=0.04)
    cbar.set_label('Probability Density', fontsize=9)
    
    # Add statistics text box
    visible_bp = np.sum(bp_probs[0, :].cpu().numpy() > 0.1)
    visible_ep = np.sum(ep_probs[0, :].cpu().numpy() > 0.1)
    avg_bp_prob = np.mean(bp_probs[0, :].cpu().numpy())
    avg_ep_prob = np.mean(ep_probs[0, :].cpu().numpy())
    
    stats_text = (f"Structure Statistics:\n"
                 f"Visible Branch Points: {visible_bp:.0f}\n"
                 f"Visible End Points: {visible_ep:.0f}\n"
                 f"Avg BP Probability: {avg_bp_prob:.3f}\n"
                 f"Avg EP Probability: {avg_ep_prob:.3f}\n"
                 f"Growth Factor: {max_temporal_scale:.2f}x")
    
    fig.text(0.02, 0.02, stats_text, fontsize=9, 
            bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.8))
    
    plt.tight_layout(rect=[0, 0.05, 1, 0.93])
    
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
        print(f"Comprehensive visualization saved to {save_path}")
    
    plt.show()
    
    return fig

if __name__ == "__main__":
    # Load trained model
    model = HierarchicalPlantSurrogateNet()
    try:
        model.load_state_dict(torch.load(MODEL_PATH))
        print(f"Loaded trained model successfully from {MODEL_PATH}")
    except Exception as e:
        print(f"Warning: Could not load trained model from {MODEL_PATH}: {e}")
        print("Using random weights - visualization may not be meaningful")
    
    # Generate random plant parameters
    params = build_random_parameter_file("temp_params.vset")
    print(f"Generated parameters: {params}")
    
    # Create comprehensive visualization
    print("\nCreating comprehensive plant visualization...")
    create_comprehensive_plant_visualization(model, params, 
                                           save_path="comprehensive_plant_visualization.png")
    
    print("\nVisualization complete!")
